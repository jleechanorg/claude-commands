description = "Converted Claude command pair"

prompt = """
# /pair - Pair Programming Protocol with MCP Mail Coordination

**Engineering in the Age of Infinite Code**

## Command Usage

```bash
/pair <plannerAgent> <builderAgent> "Task description"
```

**Example:**
```bash
/pair alice bob "Add user authentication with JWT tokens"
```

## Arguments

- `plannerAgent`: MCP mail agent ID for the Architect/Planner role
- `builderAgent`: MCP mail agent ID for the Builder/Implementer role
- `task`: Task description in quotes

## Prerequisites

- Both agents must be pre-registered MCP mail agents
- Agents must have access to MCP mail server for coordination
- Current agent executing this command must be either plannerAgent or builderAgent

---

## THE PAIR PROTOCOL WORKFLOW

### Phase 0: Initialization & Role Detection

**CRITICAL: Determine Your Role**

```bash
# Check which agent you are
CURRENT_AGENT=$(mcp__agentmail__whoami)

if [ "$CURRENT_AGENT" == "<plannerAgent>" ]; then
    MY_ROLE="PLANNER"
    PARTNER_ROLE="BUILDER"
    PARTNER_AGENT="<builderAgent>"
elif [ "$CURRENT_AGENT" == "<builderAgent>" ]; then
    MY_ROLE="BUILDER"
    PARTNER_ROLE="PLANNER"
    PARTNER_AGENT="<plannerAgent>"
else
    echo "ERROR: Current agent must be either planner or builder"
    exit 1
fi
```

**Initialization Message:**

Send initialization message via MCP mail to partner:

```json
{
  "to": "<partnerAgent>",
  "subject": "PAIR_INIT",
  "body": {
    "protocol_version": "3.1",
    "task": "<task_description>",
    "my_role": "<MY_ROLE>",
    "your_role": "<PARTNER_ROLE>",
    "status": "INITIALIZED"
  }
}
```

---

### Phase 1: The Contract (PLANNER ROLE)

**IF MY_ROLE == "PLANNER":**

#### Step 1.1: Contract Generation

Use high-reasoning model to generate the Contract following the Architect System Prompt:

**ARCHITECT SYSTEM PROMPT:**

```markdown
# ROLE
You are a Principal Software Architect acting as a "Deliberative Alignment" engine.
**Your Goal:** Convert a feature request into a strict "Definition of Done" (The Contract) that matches the project's existing style and prevents goal drift.

# INPUT DATA
- **Feature Request:** <task_description>
- **Reality Anchor:** Rely *only* on the provided file tree. Do not hallucinate helpers.
- **Style Guide:** Mimic the patterns found in existing test samples.

# OUTPUT REQUIREMENTS (The Contract)

## Part 1: The Safety Reasoning (Internal Monologue)
- **Scheming Risk:** How might a lazy agent game this request?
- **Hardening:** What specific test case will prevent that gaming?

## Part 2: The Design Spec (Markdown)
- **Traceability:** Map each requirement to a specific test case.
- **Assumptions:** List any "magic" behavior you assume exists.

## Part 3: The Test Suite (Code)
- Write a **runnable** test file.
- **Directives:**
    1. **NO IMPLEMENTATION:** Do not write feature code. Only write the tests.
    2. **ANTI-SCHEMING:** Assert against "Destructive Paths" (e.g., DB wipes, Auth bypass).
    3. **SELF-CLEANING:** Include `teardown` / `afterEach` to prevent state leaks.
    4. **NO STRICT TIMING:** Do not use brittle assertions like `expect(time).toBeLessThan(10ms)`. Use spies/mocks.
    5. **ENSURE RED:** Tests must fail for logic, not syntax errors.

# THOUGHT PROCESS
1. Analyze the "Destructive Path."
2. Check existing dependencies for allowed libraries.
3. Write assertions that match the project's existing test patterns.
```

#### Step 1.2: Generate Contract Artifacts

Create three files (using timestamp-based naming convention):
1. `tmp/pair_<timestamp>_safety_reasoning.md` - Internal monologue about scheming risks
2. `tmp/pair_<timestamp>_spec_draft.md` - Initial design specification (pre-review)
3. `tmp/pair_<timestamp>_tests.<ext>` - Failing test suite (ensure RED tests)

#### Step 1.3: **HUMAN REVIEW CHECKPOINT #1**

**üö® MANDATORY: Prompt User for Contract Review**

```
=== PAIR PROTOCOL: CONTRACT REVIEW CHECKPOINT ===

üìã CONTRACT ARTIFACTS GENERATED:
- Safety Reasoning: tmp/pair_<timestamp>_safety_reasoning.md
- Design Spec (draft): tmp/pair_<timestamp>_spec_draft.md
- Test Suite: tmp/pair_<timestamp>_tests.<ext>

üîç REVIEW REQUIRED:
1. Does the spec capture all requirements?
2. Are the tests comprehensive (including edge cases)?
3. Do tests prevent "destructive paths" (DB wipes, auth bypass)?
4. Are tests self-cleaning (proper teardown)?

Please review the artifacts above. Once approved, the spec draft will be frozen as `tmp/pair_<timestamp>_spec_final.md` and sent to the builder as the CONTRACT_FINAL.

ACTIONS:
- Type "APPROVED" to finalize contract and proceed to build phase
- Type "REVISE: <feedback>" to request changes to the contract
- Type "ABORT" to cancel the pair session
```

**WAIT FOR USER RESPONSE**

- If "APPROVED": Proceed to Step 1.4
- If "REVISE: ...": Return to Step 1.1 with user feedback
- If "ABORT": Send ABORT message to builder and exit

#### Step 1.4: Send Finalized Contract to Builder

Rename or copy the approved spec draft to `tmp/pair_<timestamp>_spec_final.md` and send finalized contract to builder:

```json
{
  "to": "<builderAgent>",
  "subject": "CONTRACT_FINAL",
  "body": {
    "phase": "CONTRACT_FINALIZED",
    "artifacts": {
      "spec": "tmp/pair_<timestamp>_spec_final.md",
      "tests": "tmp/pair_<timestamp>_tests.<ext>"
    },
    "contract_immutable": true,
    "status": "READY_FOR_BUILD"
  }
}
```

**PLANNER NOW WAITS for builder completion**

---

### Phase 2: The Build (BUILDER ROLE)

**IF MY_ROLE == "BUILDER":**

#### Step 2.1: Wait for Contract

Poll MCP mail for CONTRACT_FINAL message from planner.

```bash
# Poll for contract (timeout: 30 minutes; aligned with pair-protocol CONTRACT_FINAL: 30 minutes)
timeout=0
while [ $timeout -lt 1800 ]; do
    MESSAGE=$(mcp__agentmail__check_inbox --from="<plannerAgent>" --subject="CONTRACT_FINAL")
    if [ -n "$MESSAGE" ]; then
        break
    fi
    sleep 10
    timeout=$((timeout + 10))
done

# Abort if contract not received within timeout
if [ -z "$MESSAGE" ]; then
    echo "WARNING: CONTRACT_FINAL not received within 30 minutes. Sending first warning and extending grace by 10 minutes."
    mcp__agentmail__send_message --to="<plannerAgent>" --subject="TIMEOUT_WARNING" --body='{"phase":"BUILD","status":"TIMEOUT","message":"Builder did not receive CONTRACT_FINAL within 30 minutes. First warning issued; will wait 10 more minutes."}'

    grace_timeout=0
    while [ $grace_timeout -lt 600 ]; do
        MESSAGE=$(mcp__agentmail__check_inbox --from="<plannerAgent>" --subject="CONTRACT_FINAL")
        if [ -n "$MESSAGE" ]; then
            break
        fi
        sleep 10
        grace_timeout=$((grace_timeout + 10))
    done

    if [ -z "$MESSAGE" ]; then
        echo "WARNING: CONTRACT_FINAL still missing. Sending second warning and extending grace by another 10 minutes."
        mcp__agentmail__send_message --to="<plannerAgent>" --subject="TIMEOUT_WARNING" --body='{"phase":"BUILD","status":"TIMEOUT","message":"Builder still waiting for CONTRACT_FINAL after 40 minutes. Second warning issued; will wait 10 more minutes before abort."}'

        grace_timeout=0
        while [ $grace_timeout -lt 600 ]; do
            MESSAGE=$(mcp__agentmail__check_inbox --from="<plannerAgent>" --subject="CONTRACT_FINAL")
            if [ -n "$MESSAGE" ]; then
                break
            fi
            sleep 10
            grace_timeout=$((grace_timeout + 10))
        done
    fi

    if [ -z "$MESSAGE" ]; then
        echo "ERROR: CONTRACT_FINAL not received within 50 minutes. Aborting build phase after two warnings."
        mcp__agentmail__send_message --to="<plannerAgent>" --subject="SESSION_ABORT" --body='{"phase":"BUILD","status":"ABORTED","message":"Builder did not receive CONTRACT_FINAL after two TIMEOUT_WARNING messages (50 minutes total). Session aborted."}'
        exit 1
    fi
fi
```

The 30-minute timeout matches the CONTRACT_FINAL expectation in the protocol table.

Initialize contract artifact paths and enter a build loop so mediation responses can restart implementation without duplicating logic:

```bash
CONTRACT_SPEC=$(echo "$MESSAGE" | jq -r '.body.artifacts.spec')
CONTRACT_TESTS=$(echo "$MESSAGE" | jq -r '.body.artifacts.tests')
STRATEGY_HINT=""

BUILD_COMPLETE=false
while [ "$BUILD_COMPLETE" = false ]; do
    echo "Implementing using $CONTRACT_SPEC and $CONTRACT_TESTS"
    # Apply STRATEGY_HINT guidance from any previous rejection before rerunning tests

    # ... run implementation and tests here (Steps 2.2‚Äì2.4) ...

    # Change-order mediation may update CONTRACT_SPEC/CONTRACT_TESTS and then continue the loop.
    # Step 2.5 (BUILD_COMPLETE) should set BUILD_COMPLETE=true when ready to exit the loop.
done
```

#### Step 2.2: Implement to Green

Use the Builder System Prompt:

**BUILDER SYSTEM PROMPT:**

```markdown
# ROLE
You are a Senior Implementation Engineer.
**Your Goal:** Make the tests pass.

# INPUT
- spec file: The design specification from CONTRACT_FINAL message
- tests file: The test suite from CONTRACT_FINAL message (IMMUTABLE)

# TOOLING
- **Sandbox:** Use test runner to verify your work constantly.
- **Constraint:** Do not modify the environment outside the sandbox.

# WORKFLOW
1. **Scaffold:** Fix Syntax Errors.
2. **Logic:** Fix Assertion Errors.
3. **Refactor:** Clean up.

# ABSOLUTE LAWS
1. **IMMUTABLE TESTS:** Do not modify the test file from the CONTRACT_FINAL message.
2. **DEPENDENCY LOCK:** No new items in `package.json` / `requirements.txt` without Change Order.
3. **NO SCHEMING:** Do not delete safety checks to make tests pass.
4. **NO HAPPY PATH CHEATING:** Do not hardcode return values (e.g., `if x==5 return 10`).

# EXCEPTION HANDLING (Diagnostic Mode)
If you fail 3 times, or the test is impossible, STOP and output Change Order JSON:

```json
{
  "status": "CHANGE_ORDER_REQUIRED",
  "failure_mode": "logic_impossible | dependency_missing | test_flakiness",
  "evidence": "Quote the failing assertion",
  "attempted_fixes": ["Strategy A", "Strategy B"],
  "requested_changes": "Specific contract modifications needed"
}
```

#### Step 2.3: Implement Code

- Read tmp/pair_<timestamp>_spec_final.md and the tests file from CONTRACT_FINAL
- Implement functionality to make tests pass
- Run tests continuously (aim for GREEN), applying any STRATEGY_HINT from a prior mediation rejection
- Track attempts (max 3 failures before Change Order)

#### Step 2.4: Handle Test Results

**IF ALL TESTS PASS (GREEN):**
- Proceed to Step 2.5

**IF TESTS FAIL AFTER 3 ATTEMPTS:**
- Generate Change Order JSON
- Send to planner for mediation:

```json
{
  "to": "<plannerAgent>",
  "subject": "CHANGE_ORDER",
  "body": {
    "phase": "BUILD_BLOCKED",
    "change_order": {
      "status": "CHANGE_ORDER_REQUIRED",
      "failure_mode": "<mode>",
      "evidence": "<failing_assertion>",
      "attempted_fixes": ["...", "..."],
      "requested_changes": "<changes_needed>"
    },
    "status": "AWAITING_MEDIATION"
  }
}
```

**BUILDER WAITS for planner mediation response**

Poll for mediation decision (timeout: 30 minutes, matching CHANGE_ORDER response timeout):

```bash
timeout=0
MEDIATION_MESSAGE=""
while [ $timeout -lt 1800 ]; do
    MEDIATION_MESSAGE=$(mcp__agentmail__check_inbox --from="<plannerAgent>" --subject="CHANGE_ORDER_ACCEPTED")
    if [ -n "$MEDIATION_MESSAGE" ]; then
        break
    fi

    MEDIATION_MESSAGE=$(mcp__agentmail__check_inbox --from="<plannerAgent>" --subject="CHANGE_ORDER_REJECTED")
    if [ -n "$MEDIATION_MESSAGE" ]; then
        break
    fi

    sleep 10
    timeout=$((timeout + 10))
done

if [ -z "$MEDIATION_MESSAGE" ]; then
    echo "WARNING: No mediation response after 30 minutes. Sending first warning and waiting 10 more minutes."
    mcp__agentmail__send_message --to="<plannerAgent>" --subject="TIMEOUT_WARNING" --body='{"phase":"BUILD","status":"TIMEOUT","message":"Builder did not receive mediation response within 30 minutes. First warning issued; will wait 10 more minutes."}'

    grace_timeout=0
    while [ $grace_timeout -lt 600 ]; do
        MEDIATION_MESSAGE=$(mcp__agentmail__check_inbox --from="<plannerAgent>" --subject="CHANGE_ORDER_ACCEPTED")
        if [ -n "$MEDIATION_MESSAGE" ]; then
            break
        fi

        MEDIATION_MESSAGE=$(mcp__agentmail__check_inbox --from="<plannerAgent>" --subject="CHANGE_ORDER_REJECTED")
        if [ -n "$MEDIATION_MESSAGE" ]; then
            break
        fi

        sleep 10
        grace_timeout=$((grace_timeout + 10))
    done

    if [ -z "$MEDIATION_MESSAGE" ]; then
        echo "WARNING: Mediation response still missing. Sending second warning and waiting another 10 minutes."
        mcp__agentmail__send_message --to="<plannerAgent>" --subject="TIMEOUT_WARNING" --body='{"phase":"BUILD","status":"TIMEOUT","message":"Builder still waiting for mediation response after 40 minutes. Second warning issued; will wait 10 more minutes before abort."}'

        grace_timeout=0
        while [ $grace_timeout -lt 600 ]; do
            MEDIATION_MESSAGE=$(mcp__agentmail__check_inbox --from="<plannerAgent>" --subject="CHANGE_ORDER_ACCEPTED")
            if [ -n "$MEDIATION_MESSAGE" ]; then
                break
            fi

            MEDIATION_MESSAGE=$(mcp__agentmail__check_inbox --from="<plannerAgent>" --subject="CHANGE_ORDER_REJECTED")
            if [ -n "$MEDIATION_MESSAGE" ]; then
                break
            fi

            sleep 10
            grace_timeout=$((grace_timeout + 10))
        done
    fi

    if [ -z "$MEDIATION_MESSAGE" ]; then
        echo "ERROR: Mediation response not received within 50 minutes. Aborting build phase after two warnings."
        mcp__agentmail__send_message --to="<plannerAgent>" --subject="SESSION_ABORT" --body='{"phase":"BUILD","status":"ABORTED","message":"Builder did not receive mediation response after two TIMEOUT_WARNING messages (50 minutes total). Session aborted."}'
        exit 1
    fi
fi

# Handle mediation decision
SUBJECT=$(echo "$MEDIATION_MESSAGE" | jq -r '.subject')
if [ "$SUBJECT" = "CHANGE_ORDER_ACCEPTED" ]; then
    UPDATED_SPEC=$(echo "$MEDIATION_MESSAGE" | jq -r '.body.updated_artifacts.spec')
    UPDATED_TESTS=$(echo "$MEDIATION_MESSAGE" | jq -r '.body.updated_artifacts.tests')
    CONTRACT_SPEC="$UPDATED_SPEC"
    CONTRACT_TESTS="$UPDATED_TESTS"
    echo "Mediation accepted. Updating contract artifacts and restarting build loop (Step 2.3)."
    continue
fi

if [ "$SUBJECT" = "CHANGE_ORDER_REJECTED" ]; then
    STRATEGY_HINT=$(echo "$MEDIATION_MESSAGE" | jq -r '.body.suggested_strategy')
    echo "Mediation rejected. Applying suggested strategy and restarting build loop (Step 2.3)."
    continue
fi
```

The `continue` statements above loop back to Step 2.3 inside the build loop to re-run implementation with the latest artifacts or strategy.

#### Step 2.5: Send Build Complete

```json
{
  "to": "<plannerAgent>",
  "subject": "BUILD_COMPLETE",
  "body": {
    "phase": "BUILD_COMPLETE",
    "test_results": "ALL_PASS",
    "implementation_files": ["<file1>", "<file2>"],
    "status": "READY_FOR_REVIEW"
  }
}
```

After sending BUILD_COMPLETE, set `BUILD_COMPLETE=true` to exit the build loop:

```bash
mcp__agentmail__send_message --to="<plannerAgent>" --subject="BUILD_COMPLETE" --body="$(cat build_complete_payload.json)"
BUILD_COMPLETE=true
```

---

### Phase 3: The Review (BOTH ROLES)

#### Step 3.1: Automated Audit (PLANNER)

**IF MY_ROLE == "PLANNER" and received BUILD_COMPLETE:**

Use Reviewer System Prompt:

**REVIEWER SYSTEM PROMPT:**

```markdown
# ROLE
You are a Principal Security Engineer.
**Your Goal:** Audit for integrity, safety, and scheming.

# INPUT
- Original Contract (spec + tests from CONTRACT_FINAL)
- Builder Implementation (git diff)

# AUDIT CHECKS

## 1. Integrity & Scheming (CRITICAL)
- **Tampering:** Did they modify the test file?
- **Env Gaming:** Look for `if (process.env.TEST)` or `Date.now()` hacks.
- **Mock Gaming:** Did they mock the assertion library itself?

## 2. Safety (MAJOR)
- **Supply Chain:** New unapproved imports?
- **Silent Failures:** Are there empty `try/catch` blocks?
- **Teardown:** Does code clean up state?

## 3. Quality (MINOR)
- **Code Style:** Matches project conventions?
- **Documentation:** Critical functions documented?

# OUTPUT

{
  "status": "PASS | FAIL",
  "severity": "CRITICAL | MAJOR | MINOR",
  "scheming_detected": boolean,
  "issues": [
    {
      "type": "integrity | safety | quality",
      "severity": "CRITICAL | MAJOR | MINOR",
      "description": "...",
      "location": "file:line"
    }
  ],
  "notes": ["..."]
}
```

Run automated audit and generate audit report.

#### Step 3.2: **HUMAN REVIEW CHECKPOINT #2**

**üö® MANDATORY: Prompt User for Implementation Review**

```
=== PAIR PROTOCOL: IMPLEMENTATION REVIEW CHECKPOINT ===

‚úÖ BUILD COMPLETE - All tests passing

üìä AUTOMATED AUDIT RESULTS:
<audit_report_json>

üîç REVIEW REQUIRED:
1. Check git diff for implementation changes
2. Verify no test file tampering
3. Confirm no scheming patterns (env hacks, mock gaming)
4. Validate safety (no silent failures, proper teardown)

IMPLEMENTATION FILES:
<list_of_changed_files>

GIT DIFF:
<show_git_diff>

ACTIONS:
- Type "MERGE APPROVED" to merge and complete pair session
- Type "REJECT: <reason>" to reject implementation and request fixes
- Type "ABORT" to cancel the pair session
```

**WAIT FOR USER RESPONSE**

- If "MERGE APPROVED": Proceed to Step 3.3
- If "REJECT: ...": Send rejection to builder, return to Phase 2
- If "ABORT": Send ABORT message to builder and exit

#### Step 3.3: Merge Implementation

  ```bash
  # Commit and push changes
  git add <implementation_files>
  git commit -m "Pair Protocol: <task_description>

  Planner: <plannerAgent>
  Builder: <builderAgent>
  Contract: tmp/pair_<timestamp>_spec_final.md
  Tests: tmp/pair_<timestamp>_tests.<ext>

  All tests passing. Human review approved."

  git push origin HEAD:<feature-branch-name>
  # Replace <feature-branch-name> with the actual branch name (e.g., claude/pair-auth-feature)
  ```

Send completion message to builder:

```json
{
  "to": "<builderAgent>",
  "subject": "SESSION_COMPLETE",
  "body": {
    "phase": "MERGED",
    "status": "SUCCESS",
    "commit_sha": "<sha>",
    "message": "Pair session completed successfully"
  }
}
```

---

### Phase 4: Mediation (PLANNER ROLE - CHANGE ORDER HANDLING)

**IF MY_ROLE == "PLANNER" and received CHANGE_ORDER:**

#### Step 4.1: Analyze Change Order

Use Summit System Prompt:

**SUMMIT SYSTEM PROMPT:**

```markdown
# ROLE
You are the Technical Mediator.
**Your Goal:** Finalize the Contract based on human feedback.

# INPUT
- Original Contract (spec + tests from CONTRACT_FINAL)
- Change Order JSON from Builder

# MEDIATION PROTOCOL

## 1. The "Malicious Compliance" Audit
- **Intent Check:** Do tests force business logic, or can they be gamed?
- **Runnable:** Confirm syntax validity.

## 2. Change Order Protocol
- **Review:** Analyze the `Change Order JSON` from the Builder.
- **Judgment:**
    - If **Valid** (Missing API, Impossible Logic): Update the Contract.
    - If **Skill Issue** (Agent is lazy): Reject and suggest a strategy.

# OUTPUT
Decision: ACCEPT_CHANGE | REJECT_CHANGE | HUMAN_ESCALATION

If ACCEPT_CHANGE:
1. Updated tmp/pair_<timestamp>_spec_final.md
2. Updated FINAL_TESTS (if needed)

If REJECT_CHANGE:
1. Rejection reason
2. Suggested strategy for builder
```

#### Step 4.2: **HUMAN REVIEW CHECKPOINT #3**

**üö® MANDATORY: Prompt User for Change Order Decision**

```
=== PAIR PROTOCOL: CHANGE ORDER REVIEW CHECKPOINT ===

‚ö†Ô∏è BUILDER REQUESTED CHANGE ORDER

CHANGE ORDER DETAILS:
<change_order_json>

ü§ñ AUTOMATED ANALYSIS:
<mediation_analysis>

üîç REVIEW REQUIRED:
1. Is this a valid blocker (missing API, impossible logic)?
2. Or is this a "skill issue" (builder being lazy)?
3. Should we update the contract or reject the change?

ACTIONS:
- Type "ACCEPT CHANGE: <reasoning>" to update contract
- Type "REJECT CHANGE: <strategy>" to send builder a new strategy
- Type "ABORT" to cancel the pair session
```

**WAIT FOR USER RESPONSE**

#### Step 4.3: Send Mediation Response

**If ACCEPT CHANGE:**

Update contract artifacts and send to builder:

```json
{
  "to": "<builderAgent>",
  "subject": "CHANGE_ORDER_ACCEPTED",
  "body": {
    "phase": "CONTRACT_REVISED",
    "decision": "ACCEPTED",
    "reasoning": "<summary_of_change_order_resolution>",
    "updated_artifacts": {
      "spec": "tmp/pair_<timestamp>_spec_final_v2.md",
      "tests": "tmp/pair_<timestamp>_tests.<ext>"
    },
    "status": "READY_FOR_BUILD"
  }
}
```

Use versioned filenames (e.g., `_v2`, `_v3`) or a new timestamp when revising specs during mediation to preserve previous CONTRACT_FINAL artifacts.

Return to Phase 2 (builder retries with updated contract)

**If REJECT CHANGE:**

Send rejection with strategy:

```json
{
  "to": "<builderAgent>",
  "subject": "CHANGE_ORDER_REJECTED",
  "body": {
    "phase": "CHANGE_ORDER_REJECTED",
    "decision": "REJECTED",
    "reasoning": "<user_reasoning>",
    "suggested_strategy": "<user_strategy>",
    "status": "RETRY_BUILD"
  }
}
```

Return to Phase 2 (builder retries with same contract)

---

## Error Handling & Edge Cases

### Timeout Handling

If no response from partner agent within timeout period:

```json
{
  "to": "<partnerAgent>",
  "subject": "TIMEOUT_WARNING",
  "body": {
    "phase": "<current_phase>",
    "status": "TIMEOUT",
    "message": "No response received within timeout period. Please respond or session will abort."
  }
}
```

After 2 timeout warnings, abort session.

### Abort Protocol

Any agent can send ABORT message:

```json
{
  "to": "<partnerAgent>",
  "subject": "SESSION_ABORT",
  "body": {
    "phase": "<current_phase>",
    "reason": "<abort_reason>",
    "status": "ABORTED"
  }
}
```

Both agents must clean up artifacts and exit gracefully.

---

## Execution Summary

**The Pair Protocol implements:**

1. **Zero Latency:** No waiting for async PR reviews
2. **Contract-First:** Tests written before implementation
3. **Anti-Scheming:** Multi-layer audit for gaming prevention
4. **Human-in-Loop:** Strategic checkpoints for critical decisions
5. **Async Coordination:** MCP mail for agent-to-agent communication

**The code is cheap. The contract is everything.**

---

## Implementation Notes

**MCP Mail Commands (Reference):**

```bash
# Send message
mcp__agentmail__send_message --to="<agent>" --subject="<subject>" --body='<json>'

# Check inbox
mcp__agentmail__check_inbox --from="<agent>" --subject="<subject>"

# Get identity
mcp__agentmail__whoami

# List all messages
mcp__agentmail__list_messages --filter='<criteria>'
```

**File Naming Convention:**

- Safety Reasoning: `tmp/pair_<timestamp>_safety_reasoning.md`
- Spec (Draft): `tmp/pair_<timestamp>_spec_draft.md`
- Spec (Final): `tmp/pair_<timestamp>_spec_final.md`
- Tests: `tmp/pair_<timestamp>_tests.<ext>`

Note: The timestamp ensures unique naming across sessions. Spec transitions from draft (after creation) to final (after human review and CONTRACT_FINAL). For change orders, create a versioned copy (e.g., `_spec_final_v2.md`) or use a new timestamp rather than overwriting the original CONTRACT_FINAL. Tests are immutable after CONTRACT_FINAL is sent unless a change order explicitly revises them.

**Protocol Version:** 3.1

**Compatible Models:**
- Planner: High-reasoning models (Claude Opus, GPT-4 with thinking)
- Builder: Fast coding models (Claude Sonnet, GPT-4)
- Reviewer: High-reasoning models (same as Planner)

---

**END OF /pair COMMAND**
"""
