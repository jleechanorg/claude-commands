# HTML Templating Recommendation for WorldArchitect.AI

## Problem Summary

The current codebase has significant HTML generation issues:

1. **Duplicate HTML** - Same UI components defined in both static HTML files and JavaScript strings
2. **Maintenance Nightmare** - 600+ line HTML strings embedded in JavaScript (campaign-wizard.js)
3. **PR #539 Bug** - Changes to static HTML don't affect actual UI because it's generated by JavaScript
4. **String Concatenation** - Complex conditional logic building HTML through string manipulation
5. **No Single Source of Truth** - UI structure scattered across multiple files

## Recommended Solution: Native HTML Templates

### Why This Approach?

- **No new dependencies** - Uses native browser `<template>` elements
- **Incremental adoption** - Can migrate one component at a time
- **Maintains SPA architecture** - No server-side changes needed
- **Better separation of concerns** - HTML structure separate from JavaScript logic
- **IDE support** - HTML syntax highlighting and validation in template elements

### Implementation Design

#### 1. Template Storage (index.html)
```html
<!-- Add template section at bottom of index.html -->
<div id="templates" style="display: none;">
    <template id="tmpl-wizard-step-basics">
        <div class="wizard-step" data-step="1">
            <h3>Campaign Basics</h3>
            <div class="mb-4">
                <label class="form-label">Campaign Type</label>
                <div class="campaign-type-selection">
                    <div class="campaign-type-option" data-type="dragon-knight">
                        <i class="bi bi-shield-fill"></i>
                        <h5>Dragon Knight Campaign</h5>
                        <p>{{dragonKnightDesc}}</p>
                    </div>
                    <div class="campaign-type-option" data-type="custom">
                        <i class="bi bi-dice-6-fill"></i>
                        <h5>Custom Campaign</h5>
                        <p>{{customDesc}}</p>
                    </div>
                </div>
            </div>
            <div class="mb-3">
                <label for="wizard-title-input">Campaign Title</label>
                <input type="text" class="form-control" id="wizard-title-input"
                       placeholder="{{titlePlaceholder}}" value="{{title}}">
            </div>
            <div class="mb-3">
                <label for="wizard-setting-input">Setting/World</label>
                <textarea class="form-control" id="wizard-setting-input" rows="3"
                          placeholder="{{settingPlaceholder}}">{{setting}}</textarea>
            </div>
            <div class="mb-3">
                <div class="d-flex justify-content-between align-items-center">
                    <label for="wizard-description-input">Campaign description prompt</label>
                    <button type="button" class="btn btn-sm btn-outline-secondary"
                            id="toggle-description" aria-expanded="true">
                        <i class="bi bi-chevron-up"></i> Collapse
                    </button>
                </div>
                <div id="description-container" class="collapse show">
                    <textarea class="form-control scrollable-textarea"
                              id="wizard-description-input" rows="8"
                              placeholder="{{descriptionPlaceholder}}">{{description}}</textarea>
                </div>
            </div>
        </div>
    </template>

    <!-- More templates for other wizard steps... -->
</div>
```

#### 2. Template Helper Library (template-helper.js)
```javascript
// Simple, lightweight template helper
const TemplateHelper = {
    // Cache for compiled templates
    cache: new Map(),

    // Get and clone a template
    getTemplate(templateId) {
        const template = document.getElementById(templateId);
        if (!template) {
            throw new Error(`Template not found: ${templateId}`);
        }
        return template.content.cloneNode(true);
    },

    // Fill template with data using simple {{key}} placeholders
    fillTemplate(element, data) {
        // Replace text content
        const walker = document.createTreeWalker(
            element,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );

        let node;
        while (node = walker.nextNode()) {
            node.textContent = node.textContent.replace(
                /\{\{(\w+)\}\}/g,
                (match, key) => data[key] ?? match
            );
        }

        // Replace attributes
        element.querySelectorAll('*').forEach(el => {
            Array.from(el.attributes).forEach(attr => {
                attr.value = attr.value.replace(
                    /\{\{(\w+)\}\}/g,
                    (match, key) => data[key] ?? match
                );
            });
        });

        return element;
    },

    // Render template with data
    renderTemplate(templateId, data = {}) {
        const template = this.getTemplate(templateId);
        return this.fillTemplate(template, data);
    },

    // Helper to convert template to HTML string if needed
    templateToString(templateId, data = {}) {
        const filled = this.renderTemplate(templateId, data);
        const div = document.createElement('div');
        div.appendChild(filled);
        return div.innerHTML;
    }
};
```

#### 3. Refactored Campaign Wizard (campaign-wizard.js)
```javascript
class CampaignWizard {
    // ... existing code ...

    generateWizardHTML() {
        // OLD: 600+ lines of HTML string
        // NEW: Use templates
        const wizardData = {
            dragonKnightDesc: 'A pre-built campaign in a medieval fantasy setting',
            customDesc: 'Create your own unique campaign from scratch',
            titlePlaceholder: this.getPlaceholderForType(),
            title: this.formData.title || '',
            setting: this.formData.setting || '',
            settingPlaceholder: 'Random fantasy D&D world (auto-generate)',
            description: this.formData.description || '',
            descriptionPlaceholder: 'Describe your campaign concept...'
        };

        return `
            <div id="campaign-wizard" class="campaign-wizard">
                ${this.generateProgressBar()}
                <div class="wizard-content">
                    ${TemplateHelper.templateToString('tmpl-wizard-step-basics', wizardData)}
                </div>
                ${this.generateNavigation()}
            </div>
        `;
    }

    generateProgressBar() {
        return TemplateHelper.templateToString('tmpl-wizard-progress', {
            currentStep: this.currentStep,
            totalSteps: this.totalSteps,
            progressPercent: (this.currentStep / this.totalSteps) * 100
        });
    }
}
```

## Migration Path

### Phase 1: Infrastructure (Week 1)
1. Add template-helper.js to project
2. Include in index.html before other scripts
3. Add template section to index.html
4. Test with one simple component

### Phase 2: High-Impact Components (Week 2)
1. **Campaign Wizard** - Extract 600+ line template
2. **Structured Fields** - Extract pre/post narrative generation
3. **Campaign List** - Extract list item templates
4. Test thoroughly after each migration

### Phase 3: Remaining Components (Week 3)
1. Convert remaining innerHTML uses
2. Create shared templates for common patterns
3. Remove duplicate HTML from static files
4. Update documentation

### Phase 4: Optimization (Week 4)
1. Add template pre-compilation for performance
2. Create template registry for better organization
3. Add development-time validation
4. Consider build-time optimization

## Benefits

1. **Maintainability** - HTML changes in one place affect all uses
2. **Readability** - HTML structure visible in HTML files
3. **Performance** - Templates cached by browser
4. **Developer Experience** - Syntax highlighting, validation
5. **Testability** - Templates can be unit tested
6. **Accessibility** - Easier to audit and maintain

## Example: Fixing PR #539

With this approach, the collapsible description feature would be:

1. Added to the template in index.html
2. Automatically used by campaign-wizard.js
3. No duplicate changes needed
4. Single source of truth

## Alternative Approaches Considered

1. **Server-side rendering** - Too big a change for SPA architecture
2. **Build-time templating** - Adds build complexity
3. **Web Components** - Browser compatibility concerns
4. **Template literals only** - Still mixes HTML in JS

## Conclusion

The native template approach provides the best balance of:
- Minimal disruption to existing code
- No new dependencies
- Incremental adoption possible
- Solves the core maintenance issues

This positions the codebase for better maintainability while respecting the existing vanilla JS/SPA architecture.
