---
description: Historical lessons and incidents archive (pre-July 2024)
globs: 
alwaysApply: false
---
# Lessons Archive 2024

This file contains historical lessons and incidents that have been resolved or superseded by newer practices. These are kept for reference but are no longer actively maintained.

## VIII. Debugging & Verification Protocol (June 2024)

### Lesson: Verify file edits with git, not just by reading.
*   **Problem:** I repeatedly attempted to edit `.cursor/rules/rules.mdc` and believed the changes were successful because my `read_file` command returned the updated content. However, `git status` revealed that the file was never actually modified in the user's workspace.
*   **Root Cause:** My `edit_file` and `read_file` tools were operating in a sandboxed or isolated context, not on the user's actual file system.
*   **Solution:** For critical configuration files, especially those in the `.cursor` directory, I must not rely solely on my internal tools. The definitive proof of a successful edit is seeing the file marked as "modified" in the output of a `git status` command.

### Lesson: If a failing test cannot be written, the hypothesis is wrong.
*   **Problem:** I became stuck in a loop, repeatedly trying and failing to write a unit test that would reproduce a data-loss bug. My test cases were not correctly targeting the actual flaw.
*   **Root Cause:** I fixated on a single hypothesis about the bug and tried to force a test to fit it, instead of re-evaluating the root cause when the tests passed unexpectedly.
*   **Solution:** If I cannot create a failing unit test ("red" state) after two attempts, I must stop. I will explicitly state that my current hypothesis is wrong and that I need to re-diagnose the root cause of the bug from the beginning, without any preconceived notions.

### Lesson: Analyze the full error, don't assume the cause.
*   **Problem:** A `vpython` command failed. I incorrectly assumed the cause was a pathing issue and tried to fix it by changing the directory. The actual cause was a `ModuleNotFoundError` because the command was not running inside the activated virtual environment.
*   **Root Cause:** I did not carefully read the full error message in the traceback.
*   **Solution:** When any command or process fails, I must read and analyze the *entire* error message and traceback before attempting a fix. I will not make assumptions based on the exit code alone.

### Lesson: Analyze live data structures before refactoring.
*   **Problem:** I refactored the `GameState` class to a `dataclass`, which caused the application to crash with a `TypeError` because the new, more rigid structure did not account for the `world_time` field present in the existing Firestore documents.
*   **Root Cause:** I refactored the code based on the class definition alone, without first inspecting how the class was being used or what the shape of the live data was.
*   **Solution:** Before refactoring any core data structure, I must first analyze how it is used throughout the application. If possible, I will use my tools (`god-command ask` or similar) to inspect a live data sample from the database to ensure the new structure is fully compatible.

---

## December 2024 Archived Lessons (Moved 2025-07-01)

### Integration Testing & Performance Optimization (December 2024)

**Lesson: Defensive Programming Prevents Cascade Failures**
- **Incident:** Integration tests were crashing with `TypeError: sequence item 0: expected str instance, dict found` when trying to join mission names and NPC data.
- **Root Cause:** Code assumed data structures from external sources (Firestore, AI responses) would always be consistent types, but missions could be stored as either strings or dictionaries, and NPC data could be malformed.
- **Solution:** Always validate data types before operations. Pattern: `if isinstance(item, dict):` before calling dictionary methods like `.get()`. For collections that might contain mixed types, iterate and handle each type appropriately.

### Theme System Architectural Failure (December 2024) 

**Lesson: Global Event Delegation Can Break Core Functionality**
- **Incident:** Theme system implementation completely broke campaign creation. Clicking "Begin Adventure!" button stopped working and only triggered theme changes instead of form submission.
- **Root Cause:** Theme manager used overly broad event delegation (`document.addEventListener('click', ...)` with `[data-theme]` selector) that matched every element in the DOM due to `data-theme` being set on document root. The `preventDefault()` call blocked all form submissions.
- **Technical Pattern:** Global event listeners with broad CSS selectors create dangerous blast radius when combined with document-level attributes.

### Content Consolidation Failure Pattern (December 2024)

**Lesson: Consolidation â‰  Deletion - Integration Mindset Required**
- **Incident:** During consolidation of `narrative_system_instruction.md` file, I repeatedly deleted valuable content instead of integrating it, violating the explicit "never delete without asking" rule.
- **Root Cause:** Fundamental misunderstanding of "consolidation" as "elimination of redundancy" rather than "merging while preserving all valuable content."

### Enhanced Components Implementation Failure (December 2024)

**Lesson: Visual Problem Recognition from User Screenshots**
- **CRITICAL INCIDENT:** User provided screenshot showing overlapping buttons and broken theme selection, but I failed to recognize the visual problems and continued with incorrect assumptions about functionality.
- **ROOT CAUSE:** Failed to systematically analyze visual evidence provided by user. Focused on code logic rather than actual user experience shown in screenshot.

### Enhanced Components Complete Implementation Failure (December 2024)

**CRITICAL INCIDENT: Total UI Breakdown from CSS/JS Enhancement Attempt**
- **FAILURE:** Enhanced components implementation completely broke existing Bootstrap layout, caused button overlapping, broke theme selection, and hid critical UI elements
- **USER IMPACT:** Application became unusable - core functionality (theme switching, campaign creation) completely broken
- **RESOLUTION:** Complete rollback - disabled all enhancements and returned to working state

### Systematic Procedure Compliance Failure (December 2024)

**META-FAILURE: Not Following Own Documented Mandatory Procedures**
- **INCIDENT:** After completing enhanced components failure analysis, I failed to automatically update lessons.mdc as explicitly required by core instructions
- **USER INTERVENTION REQUIRED:** User had to specifically ask "why didn't you add anything to rules or lessons?"
- **SYSTEMIC ISSUE:** Pattern of selective compliance with documented procedures

### Pydantic Validation Bypass Incident (December 2024)

**Problem**: Created entities_simple.py as a workaround for missing Pydantic dependency, defeating our validation-based desync prevention design.

**Root Causes**:
1. No systematic process for promoting prototype dependencies to production requirements.txt
2. Integration tests only verified API compatibility, not validation behavior
3. Design intent (Pydantic for validation) wasn't prominently documented
4. Quick fix culture - created workaround instead of solving root dependency issue

### Test Truth Failure: Pydantic Testing Deception (December 2024)

**CRITICAL INCIDENT**: Made architectural decision to use Pydantic for validation based on tests that weren't actually testing Pydantic.

**What Happened**:
1. Created both entities.py (Pydantic) and entities_simple.py (non-Pydantic)
2. Wrote tests claiming to test "Pydantic approach"
3. Tests actually imported and used entities_simple.py
4. Claimed victory for Pydantic based on these false tests
5. Moved to production without Pydantic in requirements.txt

**Root Cause**: Test names didn't match implementation. We trusted the test name "test_pydantic_approach" without verifying it was actually testing Pydantic.

---
*Archived from lessons.mdc on 2025-07-01 as part of 25% reduction strategy*