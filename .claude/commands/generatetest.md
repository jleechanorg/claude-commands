--- 
description: /generatetest - Evidence-Based Test Generator (Real Mode Only)
type: llm-orchestration
execution_mode: immediate
---
## ‚ö° EXECUTION INSTRUCTIONS FOR CLAUDE
**When this command is invoked, YOU (Claude) must execute these steps immediately.**
**This is NOT documentation - these are COMMANDS to execute right now.**

**MANDATORY**: Read `.claude/skills/evidence-standards.md` before generating any test code.
This ensures generated tests follow current evidence standards.

## üö® CORE PRINCIPLES

**REAL MODE ONLY**: All generated tests use real local servers, real databases, nothing mocked.
**EVIDENCE-FIRST**: Tests generate evidence bundles directly to `/tmp/<repo>/<branch>/<work>/<timestamp>/`.
**SELF-CONTAINED**: Tests write evidence files directly - no external dependencies.
**FREE-FORM INPUT**: Accept natural language like "for this PR make sure the equipment logic works".

## üìÅ OUTPUT LOCATIONS

| Output Type | Default Location | Override Flag |
|-------------|------------------|---------------|
| **Test files** | `testing_mcp/` | `--test-dir <path>` |
| **Evidence** | `/tmp/<repo>/<branch>/<work>/<timestamp>/` | `--evidence-dir <path>` |

## üö® EXECUTION WORKFLOW

### Phase 1: Parse Free-Form Input

**Action Steps:**
1. Extract test focus from natural language input (e.g., "equipment logic", "dice rolls", "campaign creation")
2. Identify PR context if mentioned (e.g., "for this PR" ‚Üí analyze current branch changes)
3. Determine test type: MCP integration, browser automation, or hybrid
4. Generate descriptive `work_name` for evidence directory

**Example Parsing:**
```
Input: "for this PR make sure the equipment logic works"
‚Üí Focus: equipment logic
‚Üí Context: current PR/branch changes
‚Üí Type: MCP integration (equipment = game state)
‚Üí work_name: equipment_validation
```

### Phase 2: Generate Test File

**Action Steps:**
1. Create test file in `testing_mcp/test_<focus>.py` (or custom `--test-dir`)
2. Include self-contained evidence generation (methodology, evidence, notes)
3. Add `--save-evidence` and `--work-name` CLI arguments to test
4. Ensure test uses REAL servers (no mocks, no test mode)

**Generated Test Structure:**
```python
#!/usr/bin/env python3
"""
Generated by /generatetest - Evidence-Based Test
Focus: [extracted focus]
Work Name: [work_name]

REAL MODE ONLY - No mocks, no test mode
Evidence standards: .claude/skills/evidence-standards.md
"""
import argparse
import hashlib
import json
import os
import subprocess
from datetime import datetime, timezone
from pathlib import Path

# Test configuration
SERVER_URL = "http://localhost:8082"  # Real local server
WORK_NAME = "[work_name]"


def get_evidence_dir(work_name: str, timestamp: str | None = None) -> Path:
    """Create evidence directory following standards."""
    try:
        repo = subprocess.check_output(
            ["git", "rev-parse", "--show-toplevel"], stderr=subprocess.STDOUT
        ).decode().strip()
        repo_name = os.path.basename(repo)
        branch = subprocess.check_output(
            ["git", "rev-parse", "--abbrev-ref", "HEAD"], stderr=subprocess.STDOUT
        ).decode().strip()
    except FileNotFoundError as exc:
        raise RuntimeError(
            "Git not found in PATH. Ensure git is installed and available."
        ) from exc
    except subprocess.CalledProcessError as exc:
        output = exc.output.decode().strip() if exc.output else str(exc)
        raise RuntimeError(
            f"Failed to read git repository info: {output or 'unknown git error'}"
        ) from exc

    if timestamp is None:
        timestamp = datetime.now(timezone.utc).strftime("%Y%m%dT%H%M%SZ")

    evidence_dir = Path(f"/tmp/{repo_name}/{branch}/{work_name}/{timestamp}")
    evidence_dir.mkdir(parents=True, exist_ok=True)
    (evidence_dir / "artifacts").mkdir(exist_ok=True)
    return evidence_dir


def capture_git_provenance() -> dict:
    """Capture git state for evidence."""
    git_info = {
        "head_commit": None,
        "branch": None,
        "origin_main": None,
        "changed_files": [],
        "errors": [],
    }

    def _run_git(cmd):
        try:
            return subprocess.check_output(cmd, stderr=subprocess.STDOUT).decode().strip()
        except FileNotFoundError as exc:
            raise RuntimeError(
                "Git not found in PATH. Ensure git is installed and available."
            ) from exc
        except subprocess.CalledProcessError as exc:
            message = exc.output.decode().strip() if exc.output else str(exc)
            git_info["errors"].append({"cmd": " ".join(cmd), "error": message})
            return None

    git_info["head_commit"] = _run_git(["git", "rev-parse", "HEAD"])
    git_info["branch"] = _run_git(["git", "rev-parse", "--abbrev-ref", "HEAD"])
    git_info["origin_main"] = _run_git(["git", "rev-parse", "origin/main"])

    changed_raw = _run_git(["git", "diff", "--name-only", "origin/main...HEAD"])
    git_info["changed_files"] = [f for f in changed_raw.split("\n") if f] if changed_raw else []

    if not git_info["errors"]:
        git_info.pop("errors")
    return git_info


def write_with_checksum(path: Path, content: str):
    """Write file and generate SHA256 checksum."""
    path.write_text(content)
    sha256 = hashlib.sha256(content.encode()).hexdigest()
    checksum_path = Path(str(path) + ".sha256")
    # Intentionally use only the base filename in the checksum content to match
    # standard `sha256sum` output format: "{sha256}  {filename}\n".
    checksum_path.write_text(f"{sha256}  {path.name}\n")


def save_evidence(
    results,
    git_info,
    server_url,
    evidence_dir: Path,
    work_name: str,
    collection_timestamp: str,
    collection_iso: str,
):
    """Write evidence files directly (no external dependencies)."""
    # If copying artifacts into evidence_dir, strip any pre-existing .sha256 files
    # before generating new bundle-level checksums.
    # Methodology: derive from actual environment
    dev_mode = os.environ.get("WORLDAI_DEV_MODE", "not set")
    methodology = f"""# Test Methodology

## Environment
- Server: {server_url}
- WORLDAI_DEV_MODE: {dev_mode}
- Timestamp: {collection_iso}

## Git Provenance
- HEAD: {git_info.get('head_commit') or 'unknown'}
- Branch: {git_info.get('branch') or 'unknown'}
- origin/main: {git_info.get('origin_main') or 'unknown'}

## Test Scope
[Generated from actual test execution]
"""

    # Evidence: derive from actual results
    passed = sum(1 for r in results if r.passed)
    total = len(results)
    evidence = f"""# Evidence Summary

## Results: {passed}/{total} PASS

| Test | Status | Details |
|------|--------|---------|
"""
    for r in results:
        status = "‚úÖ PASS" if r.passed else "‚ùå FAIL"
        evidence += f"| {r.name} | {status} | {r.details} |\n"

    # Notes: track warnings and follow-ups derived from actual results
    warnings = []
    follow_ups = []
    failed_tests = [r for r in results if not r.passed]
    if failed_tests:
        warnings.append(f"{len(failed_tests)} test(s) failed")
        follow_ups.append("Review failed test logs for root cause analysis")

    warnings_str = "\n".join(f"- {w}" for w in warnings) if warnings else "(none)"
    followups_str = "\n".join(f"- {f}" for f in follow_ups) if follow_ups else "(none)"

    notes = f"""# Notes

## Warnings
{warnings_str}

## Follow-ups
{followups_str}
"""

    # Metadata JSON
    clean_git_info = dict(git_info)
    changed_files = clean_git_info.get("changed_files")
    if isinstance(changed_files, list):
        clean_git_info["changed_files"] = [f for f in changed_files if f]

    metadata = {
        "timestamp": collection_iso,
        "git_provenance": clean_git_info,
        "server_url": server_url,
        "results_summary": {"passed": passed, "total": total}
    }

    repo_name = evidence_dir.parts[2] if len(evidence_dir.parts) > 2 else "unknown repo"

    readme = f"""# Evidence Package Manifest

- Repository: {repo_name}
- Branch: {clean_git_info.get('branch') or 'unknown'}
- Head Commit: {clean_git_info.get('head_commit') or 'unknown'}
- Origin/Main: {clean_git_info.get('origin_main') or 'unknown'}
- Server: {server_url}
- Work Name: {work_name}
- Collected At (UTC): {collection_iso}

All files in this directory were generated directly by the test run and include
per-file SHA256 checksums for integrity verification.
"""

    # Write all files with checksums
    write_with_checksum(evidence_dir / "README.md", readme)
    write_with_checksum(evidence_dir / "methodology.md", methodology)
    write_with_checksum(evidence_dir / "evidence.md", evidence)
    write_with_checksum(evidence_dir / "notes.md", notes)
    write_with_checksum(
        evidence_dir / "metadata.json",
        json.dumps(metadata, indent=2)
    )

    print(f"Evidence saved to: {evidence_dir}")
    print("Reminder: update documentation files and regenerate checksums if you add or edit content.")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--server", default=SERVER_URL)
    parser.add_argument("--save-evidence", action="store_true",
                        help="Save evidence to /tmp structure")
    parser.add_argument("--work-name", default=WORK_NAME)
    args = parser.parse_args()

    # Capture a synchronized timestamp for directory naming and metadata
    collection_dt = datetime.now(timezone.utc)
    collection_timestamp = collection_dt.strftime("%Y%m%dT%H%M%SZ")
    collection_iso = collection_dt.isoformat()

    # Run tests against REAL server
    results = run_tests(args.server)

    if args.save_evidence:
        # Generate evidence directly (no external dependencies)
        try:
            git_info = capture_git_provenance()
        except Exception as exc:
            print(f"Warning: failed to capture git provenance: {exc}")
            git_info = {
                "head_commit": None,
                "branch": None,
                "origin_main": None,
                "changed_files": [],
                "errors": [
                    {"stage": "git_provenance_capture", "error": str(exc)}
                ],
            }
        try:
            evidence_dir = get_evidence_dir(args.work_name, collection_timestamp)
        except Exception as exc:
            print(
                "Warning: failed to derive evidence directory from git context; "
                "using fallback path"
            )
            evidence_dir = Path(
                f"/tmp/unknown/{args.work_name}/{collection_timestamp}"
            )
            evidence_dir.mkdir(parents=True, exist_ok=True)
            (evidence_dir / "artifacts").mkdir(exist_ok=True)
            git_info.setdefault("errors", []).append(
                {"stage": "get_evidence_dir", "error": str(exc)}
            )
        save_evidence(
            results,
            git_info,
            args.server,
            evidence_dir,
            args.work_name,
            collection_timestamp,
            collection_iso,
        )


if __name__ == "__main__":
    main()
```

### Phase 3: Add Evidence Standards Compliance

**Action Steps:**
1. Include git provenance capture (HEAD, origin/main, changed files)
2. Add server environment capture (process info, ports, env vars)
3. Derive ALL documentation from actual data (never hardcode)
4. Track missing/dropped data with warnings
5. Check subprocess return codes

**Evidence Standards Checklist (from `.claude/skills/evidence-standards.md`):**
- [ ] Git provenance: HEAD commit, origin/main, changed files (via `capture_git_provenance()`)
- [ ] Server environment: PID, port, env vars (via `capture_server_runtime()`)
- [ ] Checksums: SHA256 for ALL evidence files including JSONL and server logs
- [ ] Timestamp synchronization: collect all evidence in one pass
- [ ] Documentation-Data alignment: derive claims from actual data
- [ ] Centralized utilities: use `lib/evidence_utils.py`
- [ ] Raw capture: use `DEFAULT_EVIDENCE_ENV` from `server_utils.py` for automatic raw LLM capture
- [ ] JSONL file: create `request_responses.jsonl` with full request/response pairs
- [ ] Server logs: copy to `artifacts/server.log` with checksum
- [ ] Evidence mode: document capture approach with `evidence_mode` field

### Phase 4: Verify Real Mode

**Action Steps:**
1. Confirm server is running on expected port
2. Verify WORLDAI_DEV_MODE setting
3. Ensure NO mock imports or test mode flags
4. Validate API responses are from real server

**üö® MOCK MODE = INVALID EVIDENCE**:
- ‚ùå FORBIDDEN: `TESTING=true`, mock imports, fake services
- ‚ùå FORBIDDEN: Hardcoded responses or placeholder data
- ‚úÖ REQUIRED: Real local server, real database, real API responses

## üìã REFERENCE DOCUMENTATION

# /generatetest - Evidence-Based Test Generator

**Purpose**: Generate self-contained tests with built-in evidence generation

**Usage**: `/generatetest <free-form description>`

**Examples:**
```bash
/generatetest for this PR make sure the equipment logic works
/generatetest validate dice roll integrity in combat
/generatetest test campaign creation flow end-to-end
```

## üîç TEST TYPE DETECTION

**Automatic Detection from Free-Form Input:**

| Keywords | Test Type | Example Input |
|----------|-----------|---------------|
| `equipment`, `inventory`, `items`, `game_state` | MCP Integration | "equipment logic works" |
| `dice`, `roll`, `combat`, `damage` | MCP Integration | "dice rolls are fair" |
| `campaign`, `create`, `firebase` | MCP Integration | "campaign creation flow" |
| `browser`, `ui`, `page`, `click` | Browser Automation | "landing page loads correctly" |
| `login`, `oauth`, `auth` | Browser + Auth | "login flow works" |

**Default**: MCP Integration (most common for this project)

## üìä GENERATED TEST REQUIREMENTS

Every generated test MUST include:

### 1. Evidence Generation Function
```python
def save_evidence(
    results,
    git_info,
    server_url,
    evidence_dir: Path,
    work_name: str,
    collection_timestamp: str,
    collection_iso: str,
):
    """Write evidence files directly from ACTUAL test data."""
    # ‚úÖ Derive from os.environ, not hardcoded
    dev_mode = os.environ.get("WORLDAI_DEV_MODE", "not set")

    # ‚úÖ Track missing data with warnings
    missing_items = []

    # ‚úÖ Use correct denominators (found/total, not found/min)
    stats_col = f"{found}/{len(total_items)} (need {min_required})"

    # ‚úÖ Write with checksums
    write_with_checksum(evidence_dir / "methodology.md", methodology)
```

### 2. CLI Arguments for Evidence
```python
parser.add_argument("--save-evidence", action="store_true")
parser.add_argument("--work-name", default="<auto_generated>")
```

### 3. Real Mode Verification
```python
def verify_real_mode(server_url):
    """Verify server is real, not mocked."""
    response = requests.get(f"{server_url}/health")
    assert response.status_code == 200
    assert "mock" not in response.text.lower()
```

### 4. Git Provenance Capture
```python
def capture_git_provenance():
    """Capture git state for evidence."""
    try:
        changed_raw = subprocess.check_output(
            ["git", "diff", "--name-only", "origin/main...HEAD"],
            stderr=subprocess.STDOUT,
        ).decode()
        changed_files = [f for f in changed_raw.split("\n") if f]
        return {
            "head_commit": subprocess.check_output(["git", "rev-parse", "HEAD"], stderr=subprocess.STDOUT).decode().strip(),
            "branch": subprocess.check_output(["git", "branch", "--show-current"], stderr=subprocess.STDOUT).decode().strip(),
            "origin_main": subprocess.check_output(["git", "rev-parse", "origin/main"], stderr=subprocess.STDOUT).decode().strip(),
            "changed_files": changed_files,
        }
    except (subprocess.CalledProcessError, FileNotFoundError) as exc:
        raise RuntimeError(f"Git provenance capture failed: {exc}") from exc
```

> Wrap git calls in try/except so missing remotes or detached HEADs surface clear
> errors instead of crashing generation. Always filter empty strings from
> `changed_files` to avoid `[""]` payloads.

## üö® EVIDENCE STANDARDS COMPLIANCE

From `.claude/skills/evidence-standards.md`:

| Requirement | Implementation |
|-------------|----------------|
| **Derive claims from data** | `os.environ.get()`, not hardcoded strings |
| **Warn on missing data** | Track `missing_item_ids` list, add to notes |
| **Correct denominators** | `found/total (need min)`, not `found/min` |
| **Check return codes** | `if result.returncode != 0: warn()` |
| **Single run attribution** | Evidence bundle references ONE test run |
| **Git provenance** | HEAD, origin/main, changed files |
| **Checksums** | SHA256 via `write_with_checksum()` helper |
| **Self-contained** | No external script dependencies |

## üîß PRIORITY MATRIX

```
üö® CRITICAL: Blocks core functionality, data corruption risk
‚ö†Ô∏è HIGH: Significant degradation, wrong behavior
üìù MEDIUM: Minor issues, cosmetic problems
‚ÑπÔ∏è LOW: Documentation, edge cases
```

**Stop Rule**: üö® CRITICAL ‚Üí Stop testing, fix immediately, verify, resume

## ‚úÖ COMPLETION CRITERIA

- [ ] Test file created in `testing_mcp/` (or custom dir)
- [ ] Self-contained evidence generation (no external dependencies)
- [ ] `write_with_checksum()` helper included
- [ ] `get_evidence_dir()` helper included
- [ ] Real mode verified (no mocks, no TESTING=true)
- [ ] Git provenance captured
- [ ] All results derived from actual data
- [ ] Missing data tracked with warnings