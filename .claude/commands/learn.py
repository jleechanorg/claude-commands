#!/usr/bin/env python3
"""
Enhanced /learn command implementation
Analyzes and documents learnings from corrections and mistakes using sequential thinking
Supports automatic CLAUDE.md proposals and learning PR creation
"""

import subprocess
import sys
from datetime import datetime
from pathlib import Path


# Branch management functions for clean branch workflow
def get_current_branch():
    """Get the current branch name"""
    try:
        result = subprocess.run(
            ["git", "branch", "--show-current"],
            capture_output=True,
            text=True,
            check=True,
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError:
        return None


def switch_to_main_and_update():
    """Switch to main branch and update it"""
    try:
        # Check if there are uncommitted changes
        result = subprocess.run(
            ["git", "status", "--porcelain"], capture_output=True, text=True, check=True
        )

        if result.stdout.strip():
            # There are uncommitted changes, stash them
            subprocess.run(
                ["git", "stash", "push", "-m", "Auto-stash before learn command"],
                check=True,
            )

        # Switch to main
        subprocess.run(["git", "checkout", "main"], check=True)
        # Pull latest changes
        subprocess.run(["git", "pull", "origin", "main"], check=True)
        return True
    except subprocess.CalledProcessError as e:
        print(f"Error switching to main: {e}")
        return False


def create_clean_learning_branch():
    """Create a clean learning branch from main"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    branch_name = f"learn-{timestamp}"

    try:
        # Create new branch from main
        subprocess.run(["git", "checkout", "-b", branch_name], check=True)
        return branch_name
    except subprocess.CalledProcessError as e:
        print(f"Error creating learning branch: {e}")
        return None


def return_to_original_branch(original_branch):
    """Return to the original branch"""
    if original_branch:
        try:
            subprocess.run(["git", "checkout", original_branch], check=True)
            return True
        except subprocess.CalledProcessError as e:
            print(f"Error returning to original branch: {e}")
            return False
    return False


def create_learning_pr(branch_name, learning_content):
    """Create a PR for the learning branch"""
    try:
        # Push the branch
        subprocess.run(["git", "push", "origin", f"HEAD:{branch_name}"], check=True)

        # Create PR
        pr_title = f"learn: {learning_content[:50]}..."
        pr_body = f"""## Learning Summary

ðŸ¤– **Automated Learning Documentation**

**Content**: {learning_content}

**Context**: Generated by /learn command with clean branch workflow

**Memory MCP Integration**: Learning persisted to knowledge graph

ðŸ¤– Generated with [Claude Code](https://claude.ai/code)
"""

        result = subprocess.run(
            ["gh", "pr", "create", "--title", pr_title, "--body", pr_body],
            capture_output=True,
            text=True,
            check=True,
        )

        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"Error creating PR: {e}")
        return None


def analyze_recent_conversation():
    """Analyze recent conversation for learnings"""
    # In real implementation, this would analyze chat history
    # For now, return placeholder
    return {"corrections": [], "self_corrections": [], "patterns": []}


def check_existing_learning(learning, file_path):
    """Check if learning already exists in file"""
    if not file_path.exists():
        return False

    content = file_path.read_text()
    # Normalize learning for comparison
    normalized = learning.lower().strip()

    # Check for similar content
    if normalized in content.lower():
        return True

    # Check for key terms
    key_terms = extract_key_terms(learning)
    matches = sum(1 for term in key_terms if term in content.lower())

    return matches >= len(key_terms) * 0.7  # 70% match threshold


def extract_key_terms(text):
    """Extract key terms from learning"""
    # Remove common words
    common_words = {
        "the",
        "a",
        "an",
        "is",
        "are",
        "was",
        "were",
        "to",
        "of",
        "in",
        "for",
        "use",
        "always",
        "never",
    }
    words = text.lower().split()
    return [w for w in words if w not in common_words and len(w) > 3]


def categorize_learning(learning):
    """Determine category for learning"""
    categories = {
        "commands": ["command", "run", "execute", "bash", "python"],
        "testing": ["test", "playwright", "browser", "testing"],
        "venv": ["venv", "virtual", "activate", "vpython"],
        "git": ["git", "branch", "commit", "push", "pr"],
        "paths": ["path", "directory", "file", "root"],
        "tools": ["tool", "available", "installed", "exists"],
    }

    learning_lower = learning.lower()
    for category, keywords in categories.items():
        if any(kw in learning_lower for kw in keywords):
            return category

    return "general"


def add_learning_to_file(learning, category, file_path):
    """Add learning to appropriate section in file"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")

    if not file_path.exists():
        return False

    content = file_path.read_text()

    # Find category section
    section_pattern = f"## {category.title()}"
    if section_pattern not in content:
        # Add new category section
        content += f"\n\n{section_pattern}\n\n"

    # Find insertion point
    lines = content.split("\n")
    insert_index = None

    for i, line in enumerate(lines):
        if line.strip() == section_pattern:
            # Find next section or end
            for j in range(i + 1, len(lines)):
                if lines[j].startswith("##"):
                    insert_index = j
                    break
            else:
                insert_index = len(lines)
            break

    if insert_index:
        new_line = f"- âœ… {learning} *(added {timestamp})*"
        lines.insert(insert_index, new_line)

        # Write back
        file_path.write_text("\n".join(lines))
        return True

    return False


def create_memory_mcp_entity(learning_content, category):
    """Create entity in Memory MCP for the learning"""
    try:
        # Generate entity name
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        entity_name = f"learning-{category}-{timestamp}"

        # Create entity with proper observations
        entity_data = {
            "name": entity_name,
            "entityType": "learning",
            "observations": [
                "Classification: âœ… Best Practice",
                f"Category: {category.title()}",
                f"Content: {learning_content}",
                "Context: Generated by /learn command with clean branch workflow",
                f"Timestamp: {datetime.now().isoformat()}",
            ],
        }

        # This would call Memory MCP in real implementation
        # For now, just return the entity data
        return entity_data
    except Exception as e:
        print(f"Error creating Memory MCP entity: {e}")
        return None


def process_learn_command(args):
    """Process /learn command with clean branch workflow"""
    project_root = Path(__file__).parent.parent.parent
    learnings_file = project_root / ".claude/learnings.md"
    claude_md = project_root / "CLAUDE.md"

    # Save current branch
    original_branch = get_current_branch()
    if not original_branch:
        return "Error: Could not determine current branch"

    learning_content = " ".join(args) if args else "Auto-detected learning"

    try:
        # Step 1: Switch to main and update
        if not switch_to_main_and_update():
            return "Error: Could not switch to main branch"

        # Step 2: Create clean learning branch
        learning_branch = create_clean_learning_branch()
        if not learning_branch:
            return_to_original_branch(original_branch)
            return "Error: Could not create learning branch"

        # Step 3: Process the learning
        if not args:
            # Analyze recent conversation
            analysis = analyze_recent_conversation()
            if not analysis["corrections"] and not analysis["self_corrections"]:
                return_to_original_branch(original_branch)
                return "No recent corrections or learnings detected to document."

            # Process found learnings
            results = []
            for learning in analysis["corrections"] + analysis["self_corrections"]:
                if not check_existing_learning(learning, learnings_file):
                    category = categorize_learning(learning)
                    if add_learning_to_file(learning, category, learnings_file):
                        results.append(f"Added to {category}: {learning}")
                        # Create Memory MCP entity
                        create_memory_mcp_entity(learning, category)

            learning_content = (
                "\n".join(results)
                if results
                else "All detected learnings already documented."
            )

        else:
            # Specific learning provided
            learning = " ".join(args)

            # Check if already exists
            if check_existing_learning(learning, learnings_file):
                return_to_original_branch(original_branch)
                return "This learning already exists or is very similar to existing documentation."

            # Categorize and add
            category = categorize_learning(learning)

            # Determine if critical enough for CLAUDE.md
            critical_indicators = ["always", "never", "must", "critical", "important"]
            is_critical = any(ind in learning.lower() for ind in critical_indicators)

            if is_critical:
                # Add to CLAUDE.md
                # For now, just add to learnings.md
                if add_learning_to_file(learning, category, learnings_file):
                    learning_content = (
                        f"Added CRITICAL learning to CLAUDE.md: {learning}"
                    )
                    create_memory_mcp_entity(learning, category)
                else:
                    return_to_original_branch(original_branch)
                    return "Failed to add learning. Please check file structure."
            else:
                # Add to learnings.md
                if add_learning_to_file(learning, category, learnings_file):
                    learning_content = (
                        f"Added learning to {category} category: {learning}"
                    )
                    create_memory_mcp_entity(learning, category)
                else:
                    return_to_original_branch(original_branch)
                    return "Failed to add learning. Please check file structure."

        # Step 4: Commit changes
        try:
            subprocess.run(["git", "add", "-A"], check=True)
            subprocess.run(
                ["git", "commit", "-m", f"learn: {learning_content[:50]}..."],
                check=True,
            )
        except subprocess.CalledProcessError as e:
            return_to_original_branch(original_branch)
            return f"Error committing changes: {e}"

        # Step 5: Create PR
        pr_url = create_learning_pr(learning_branch, learning_content)
        if not pr_url:
            return_to_original_branch(original_branch)
            return "Error creating PR"

        # Step 6: Return to original branch
        return_to_original_branch(original_branch)

        return f"âœ… Learning documented successfully!\nPR created: {pr_url}\nContent: {learning_content}"

    except Exception as e:
        # Ensure we always return to original branch
        return_to_original_branch(original_branch)
        return f"Error processing learning: {e}"


if __name__ == "__main__":
    # For testing
    result = process_learn_command(sys.argv[1:])
    print(result)
