{"id":"DICE-0nv","content_hash":"08af5c3f21b31a70616fc773fa95ca24b0a6c698db8616e338cfa8bea684f4cb","title":"fix(dice): Precompile combat keyword regex patterns","description":"Regex patterns using r'\\b' + re.escape(k) + r'\\b' are recompiled on EVERY function call. Applied to user-controlled text without length limits. Same issue in 3 different functions.\n\nLocations:\n- _should_require_dice_rolls_for_turn() - line 2777\n- _detect_combat_in_narrative() - line 2920\n- _validate_combat_dice_integrity() - line 3037\n\nWhat Could Go Wrong:\n- Malicious user submits 10K+ character narrative\n- Regex compilation overhead × 15 keywords × every turn\n- CPU spike causes request timeout\n- No input length validation before regex matching\n\nRequired Fix:\n1. Create module-level precompiled patterns:\n   _COMBAT_KEYWORD_PATTERNS = {\n       keyword: re.compile(r'\\b' + re.escape(keyword) + r'\\b', re.IGNORECASE)\n       for keyword in COMBAT_ACTION_KEYWORDS\n   }\n\n2. Add input length limit (5000 chars)\n3. Use precompiled patterns in all 3 functions","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-20T16:42:37.099789-08:00","updated_at":"2025-12-20T17:30:09.29068-08:00","closed_at":"2025-12-20T17:30:09.29068-08:00","source_repo":"."}
{"id":"DICE-1vf","content_hash":"ba7ffbc1db790f75dd0954e7bc338e9e6403fca4fea835533d646a7c6c9b37a2","title":"fix(audit): Add error handling to Firebase collection group query","description":"Collection group query iterates ALL campaigns across ALL users without pagination. If campaign is deleted during iteration, query returns partial/inconsistent data. No error handling for concurrent modifications.\n\nLocation: scripts/audit_dice_rolls.py:66-72\n\nWhat Could Go Wrong:\n- Campaign deleted mid-query → campaign_doc.to_dict() raises exception\n- Large databases (1000+ campaigns) could timeout\n- No transaction isolation in Firestore streaming queries\n- Script crashes instead of graceful degradation\n\nRequired Fix:\n1. Wrap query in try/except\n2. Add try/except around campaign_doc.to_dict()\n3. Validate campaign_data is not None\n4. Return None, None on errors with diagnostic message","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-20T16:42:37.630431-08:00","updated_at":"2025-12-20T17:30:10.123335-08:00","closed_at":"2025-12-20T17:30:10.123335-08:00","source_repo":"."}
{"id":"DICE-345","content_hash":"57834a46f25676908c833b8d68527fa455d90d460ba269bcf8430d5ce22d6e1e","title":"Dice integrity reprompt not strategy-aware (Gemini 3 code_execution)","description":"Reprompt text says the model can fix dice integrity by using tool_requests or code_execution, but Gemini 3 runs in code_execution-only mode. If the model chooses tool_requests, the reprompt can never resolve and may fall back to invalid original response.","acceptance_criteria":"Make reprompt guidance conditional on dice strategy (code_execution vs tool_requests). Ensure Gemini 3 reprompts only allow code_execution remediation.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-20T15:09:15.521908-08:00","updated_at":"2025-12-20T15:47:24.271954-08:00","closed_at":"2025-12-20T15:47:24.271954-08:00","source_repo":"."}
{"id":"DICE-axo","content_hash":"01e7415d5e1828e2f4143401135741929d4c315c5fade74c98afdf8fdc7ba8bd","title":"fix(dice): Add type check for damage_total extraction","description":"damage_total extraction could fail if damage field is not a dict. Type safety issue from external AI review feedback.\n\nLocation: mvp_site/game_state.py:1616\n\nProblem:\n- result.get('damage', {}) provides default {} if key missing\n- BUT if result.get('damage') checks truthiness, not type\n- If damage is a non-empty string/list, it passes the check but fails on .get('total')\n\nExample Failure Case:\nresult = {'damage': 'high'}  # String instead of dict\n# result.get('damage') → 'high' (truthy, passes check)\n# result.get('damage', {}).get('total', 'N/A') → 'high'.get('total') → AttributeError\n\nRecommended Fix:\ndamage = result.get('damage')\ndamage_total = damage.get('total', 'N/A') if isinstance(damage, dict) else 'N/A'\n\nImpact: Logging-only code (not critical path), but could cause crashes","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-20T16:42:38.161943-08:00","updated_at":"2025-12-20T17:30:10.921822-08:00","closed_at":"2025-12-20T17:30:10.921822-08:00","source_repo":"."}
{"id":"DICE-ayy","content_hash":"c27a83d3db9d0e90fceb43615d4a689adc5c7438dd08e5f0bfc38a8e1f0d45f6","title":"feat(dice): Add narrative dice pattern detection to catch LLM fabrications","description":"Current dice integrity system only checks if user input contains combat keywords to require dice rolls. This misses cases where the LLM smartly determines a skill check is needed (e.g., Intimidation) but fabricates dice in the narrative without using code_execution.\n\n**Example Case**:\n- User input: \"Demand Lantry's Release\" (no combat keywords)\n- LLM response: Contains \"[DICE: Intimidation 1d20+9 = 25]\" in narrative\n- Current behavior: No enforcement because user input had no combat keywords\n- Result: Dice fabrication in narrative, dice_rolls field = None\n\n**Gap**:\n- ✅ Detects combat keywords in user input\n- ❌ Doesn't detect dice that LLM adds to narrative\n- ❌ Allows LLM to fabricate dice when it intelligently determines a check is needed\n\n**Required Fix**:\nAdd post-generation detection of dice patterns in LLM narrative:\n\n1. After parsing narrative, scan for dice patterns:\n   - [DICE: ...] format\n   - 1d20 + 9 = 25 patterns  \n   - \"rolled 1d20\" phrases\n\n2. If dice found in narrative but no code_execution:\n   - Set dice_integrity_violation = True\n   - Trigger reprompt to enforce code_execution\n\n3. Add to _validate_combat_dice_integrity() or create new _detect_narrative_dice_fabrication()\n\n**Impact**:\n- Closes major loophole where smart LLM decisions bypass dice enforcement\n- Ensures ALL dice in narrative come from real code_execution\n- Catches fabrications regardless of how user phrased input\n\n**Location**: mvp_site/llm_service.py, after narrative parsing (around line 3669)\n\n**Test Case**:\n- User: \"Demand the guard stand down\"\n- LLM: Generates Intimidation check in narrative\n- System: Detects dice pattern → requires code_execution → real dice rolled","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-20T17:58:19.133363-08:00","updated_at":"2025-12-20T20:43:12.150018-08:00","closed_at":"2025-12-20T20:43:12.150018-08:00","source_repo":"."}
{"id":"DICE-b5g","content_hash":"0dab94bdf6abb9fe5f5f31dfa5537ed695cb6cc57a90f89b0a3d850d21bf0d8e","title":"Follow-up docs stored in /tmp without mktemp isolation","description":"Docs were written to fixed paths (/tmp/next_steps_prompt.md, /tmp/quick_next_steps.txt), violating the temp-file isolation guideline and risking cross-branch collisions.","acceptance_criteria":"Regenerate docs using mktemp with branch-qualified filenames, or store under repo tmp/ with branch-specific subdir.","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-20T15:39:28.896276-08:00","updated_at":"2025-12-20T15:44:31.988649-08:00","closed_at":"2025-12-20T15:44:31.988649-08:00","source_repo":"."}
{"id":"DICE-cuc","content_hash":"cc11c00c484b2277dfa510f72589fa5da23f03de3f642c37f9d524470fe654d4","title":"Follow-up docs contain unverified/incorrect PR context and status claims","description":"The generated /tmp/next_steps_prompt.md and /tmp/quick_next_steps.txt include specific claims (CI status, recent commits, files changed, fixes implemented) that are not validated against current PR #2506 state. This can mislead next-session execution.","acceptance_criteria":"Regenerate follow-up docs using live PR #2506 data (gh pr view/checks/log), or remove unverifiable claims. Include date/time of snapshot.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-20T15:39:22.649527-08:00","updated_at":"2025-12-20T15:44:26.666956-08:00","closed_at":"2025-12-20T15:44:26.666956-08:00","source_repo":"."}
{"id":"DICE-la1","content_hash":"0bd3eb326987f740b56ca6002b6b5e776dd43c73a026b3d08abc0ecf5919391c","title":"refactor(dice): Add explicit None check in fabrication detection","description":"Function signature allows code_execution_evidence: dict[str, Any] | None but implementation checks 'if not code_execution_evidence' which treats empty dict {} as falsy.\n\nLocation: mvp_site/llm_service.py:1594\n\nCurrent Behavior: Works fine - extract_code_execution_evidence() never returns None or {}\nRisk: Future refactoring could break this assumption\n\nCurrent Implementation Returns:\n{\n    \"code_execution_used\": False,  # Always has keys\n    \"executable_code_parts\": 0,\n    \"code_execution_result_parts\": 0,\n    \"stdout\": \"\",\n    \"stdout_is_valid_json\": False,\n}\n\nRecommended Fix (Defensive Programming):\nif code_execution_evidence is None:\n    return False\n\nImpact: LOW CURRENT RISK - only if extract_code_execution_evidence() is refactored to return None\nSeverity: HIGH (potential) but LOW (current)\nAction: OPTIONAL - Defensive programming recommended for future-proofing","status":"closed","priority":4,"issue_type":"chore","created_at":"2025-12-20T16:42:38.702916-08:00","updated_at":"2025-12-20T17:30:11.977562-08:00","closed_at":"2025-12-20T17:30:11.977562-08:00","source_repo":"."}
{"id":"DICE-nqa","content_hash":"0241b37da2c4ace7493231a961d4227825e6f2fab66c06bd6c5b1da2f849aea0","title":"fix(dice): Add loop counter to reprompt logic","description":"Reprompt logic checks MAX_MISSING_FIELD_REPROMPT_ATTEMPTS \u003e 0 but has NO loop counter. Current code performs only ONE reprompt attempt. If this constant is ever increased to allow multiple retries, there's no mechanism to limit iterations.\n\nLocation: mvp_site/llm_service.py:3669-3758\n\nWhat Could Go Wrong:\n- Future changes increasing retry limit could cause infinite loops\n- LLM API failures during reprompt could burn API quota\n- No timeout protection on repeated LLM calls\n- Design is fragile - works only because constant is likely 1\n\nRequired Fix:\nAdd explicit loop with counter and improvement detection:\n- for attempt in range(MAX_MISSING_FIELD_REPROMPT_ATTEMPTS)\n- Success detection: if len(reprompt_missing) == 0: break\n- Stall detection: if len(reprompt_missing) \u003e= len(missing_fields): break\n- Update missing_fields for next iteration","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-20T16:42:36.563871-08:00","updated_at":"2025-12-20T17:30:09.000759-08:00","closed_at":"2025-12-20T17:30:09.000759-08:00","source_repo":"."}
{"id":"DICE-oro","content_hash":"13fc9a9a5c214a696242434fd61b7b5d04e5fbf8791e0934e56f6ca4290407b6","title":"Dice requirement triggers on generic substrings (false positives)","description":"_should_require_dice_rolls_for_turn now flags any substring match for generic keywords (roll/check/help/hit/etc.), causing dice-required enforcement in non-combat turns (e.g., “help me”, “check the door”, “troll”). This can trigger missing-field reprompts and stall responses.","acceptance_criteria":"Use word-boundary matching and/or intent heuristics so non-combat text does not require dice. Add/adjust tests to cover false-positive cases (e.g., 'help me', 'check the door', 'troll').","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-20T15:09:08.519563-08:00","updated_at":"2025-12-20T15:47:16.323028-08:00","closed_at":"2025-12-20T15:47:16.323028-08:00","source_repo":"."}
