from flask import Flask, request, jsonify
from werkzeug.security import generate_password_hash, check_password_hash
from flask_sqlalchemy import SQLAlchemy
from flask_marshmallow import Marshmallow
from marshmallow import Schema, fields, validate, ValidationError, post_load
import re
import uuid
from datetime import datetime, timezone
from typing import Dict, Any, Optional
import logging


# Initialize Flask app and extensions
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['SECRET_KEY'] = 'your-secret-key-here'

db = SQLAlchemy(app)
ma = Marshmallow(app)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class User(db.Model):
    """User model for database storage."""

    __tablename__ = 'users'

    id = db.Column(db.String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    email = db.Column(db.String(255), unique=True, nullable=False, index=True)
    username = db.Column(db.String(80), unique=True, nullable=False, index=True)
    password_hash = db.Column(db.String(255), nullable=False)
    first_name = db.Column(db.String(100), nullable=False)
    last_name = db.Column(db.String(100), nullable=False)
    is_active = db.Column(db.Boolean, default=True, nullable=False)
    is_verified = db.Column(db.Boolean, default=False, nullable=False)
    created_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc), nullable=False)
    updated_at = db.Column(db.DateTime, default=lambda: datetime.now(timezone.utc),
                          onupdate=lambda: datetime.now(timezone.utc), nullable=False)
    last_login = db.Column(db.DateTime, nullable=True)

    def set_password(self, password: str) -> None:
        """Hash and set user password."""
        self.password_hash = generate_password_hash(password)

    def check_password(self, password: str) -> bool:
        """Check if provided password matches hash."""
        return check_password_hash(self.password_hash, password)

    def to_dict(self) -> Dict[str, Any]:
        """Convert user to dictionary (excluding sensitive data)."""
        return {
            'id': self.id,
            'email': self.email,
            'username': self.username,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'is_active': self.is_active,
            'is_verified': self.is_verified,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat(),
            'last_login': self.last_login.isoformat() if self.last_login else None
        }

    def __repr__(self):
        return f'<User {self.username}>'


class UserRegistrationSchema(Schema):
    """Schema for user registration validation."""

    email = fields.Email(
        required=True,
        validate=validate.Length(min=5, max=255),
        error_messages={'invalid': 'Please provide a valid email address.'}
    )

    username = fields.Str(
        required=True,
        validate=[
            validate.Length(min=3, max=80),
            validate.Regexp(
                r'^[a-zA-Z0-9_]+$',
                error='Username can only contain letters, numbers, and underscores.'
            )
        ]
    )

    password = fields.Str(
        required=True,
        validate=validate.Length(min=8, max=128),
        load_only=True
    )

    first_name = fields.Str(
        required=True,
        validate=validate.Length(min=1, max=100)
    )

    last_name = fields.Str(
        required=True,
        validate=validate.Length(min=1, max=100)
    )

    @post_load
    def validate_password_strength(self, data, **kwargs):
        """Validate password strength requirements."""
        password = data.get('password')
        if not password:
            return data

        errors = []

        # Check for at least one uppercase letter
        if not re.search(r'[A-Z]', password):
            errors.append('Password must contain at least one uppercase letter.')

        # Check for at least one lowercase letter
        if not re.search(r'[a-z]', password):
            errors.append('Password must contain at least one lowercase letter.')

        # Check for at least one digit
        if not re.search(r'\d', password):
            errors.append('Password must contain at least one digit.')

        # Check for at least one special character
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
            errors.append('Password must contain at least one special character.')

        if errors:
            raise ValidationError({'password': errors})

        return data


class UserResponseSchema(Schema):
    """Schema for user response serialization."""

    id = fields.Str()
    email = fields.Email()
    username = fields.Str()
    first_name = fields.Str()
    last_name = fields.Str()
    is_active = fields.Bool()
    is_verified = fields.Bool()
    created_at = fields.DateTime()
    updated_at = fields.DateTime()
    last_login = fields.DateTime(allow_none=True)


# Initialize schemas
user_registration_schema = UserRegistrationSchema()
user_response_schema = UserResponseSchema()


def validate_unique_email(email: str) -> bool:
    """Check if email is already registered."""
    return User.query.filter_by(email=email.lower()).first() is None


def validate_unique_username(username: str) -> bool:
    """Check if username is already taken."""
    return User.query.filter_by(username=username.lower()).first() is None


@app.route('/api/users/register', methods=['POST'])
def register_user():
    """
    Register a new user with email validation, password hashing, and database storage.

    Expected JSON payload:
    {
        "email": "user@example.com",
        "username": "username",
        "password": "SecurePassword123!",
        "first_name": "John",
        "last_name": "Doe"
    }

    Returns:
        201: User created successfully
        400: Validation errors
        409: Email or username already exists
        500: Internal server error
    """
    try:
        # Parse and validate JSON input
        if not request.is_json:
            return jsonify({
                'error': 'Content-Type must be application/json',
                'success': False
            }), 400

        json_data = request.get_json()
        if not json_data:
            return jsonify({
                'error': 'No JSON data provided',
                'success': False
            }), 400

        # Validate input data
        try:
            validated_data = user_registration_schema.load(json_data)
        except ValidationError as err:
            logger.warning(f"Registration validation failed: {err.messages}")
            return jsonify({
                'error': 'Validation failed',
                'details': err.messages,
                'success': False
            }), 400

        # Normalize email and username
        email = validated_data['email'].lower().strip()
        username = validated_data['username'].lower().strip()

        # Check for existing email
        if not validate_unique_email(email):
            logger.warning(f"Registration failed: Email {email} already exists")
            return jsonify({
                'error': 'Email address is already registered',
                'success': False
            }), 409

        # Check for existing username
        if not validate_unique_username(username):
            logger.warning(f"Registration failed: Username {username} already exists")
            return jsonify({
                'error': 'Username is already taken',
                'success': False
            }), 409

        # Create new user
        user = User(
            email=email,
            username=username,
            first_name=validated_data['first_name'].strip(),
            last_name=validated_data['last_name'].strip()
        )

        # Set password (will be hashed automatically)
        user.set_password(validated_data['password'])

        # Save to database
        try:
            db.session.add(user)
            db.session.commit()

            logger.info(f"User {username} registered successfully with ID {user.id}")

            # Return user data (excluding sensitive information)
            user_data = user_response_schema.dump(user)

            return jsonify({
                'message': 'User registered successfully',
                'user': user_data,
                'success': True
            }), 201

        except Exception as db_error:
            db.session.rollback()
            logger.error(f"Database error during registration: {str(db_error)}")
            return jsonify({
                'error': 'Failed to create user account',
                'success': False
            }), 500

    except Exception as e:
        logger.error(f"Unexpected error during registration: {str(e)}")
        return jsonify({
            'error': 'Internal server error',
            'success': False
        }), 500


@app.route('/api/users/<user_id>', methods=['GET'])
def get_user(user_id: str):
    """Get user information by ID."""
    try:
        user = User.query.get(user_id)
        if not user:
            return jsonify({
                'error': 'User not found',
                'success': False
            }), 404

        user_data = user_response_schema.dump(user)
        return jsonify({
            'user': user_data,
            'success': True
        }), 200

    except Exception as e:
        logger.error(f"Error retrieving user {user_id}: {str(e)}")
        return jsonify({
            'error': 'Internal server error',
            'success': False
        }), 500


@app.route('/api/users', methods=['GET'])
def list_users():
    """List all users with pagination."""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = min(request.args.get('per_page', 10, type=int), 100)

        users = User.query.paginate(
            page=page,
            per_page=per_page,
            error_out=False
        )

        user_list = user_response_schema.dump(users.items, many=True)

        return jsonify({
            'users': user_list,
            'pagination': {
                'page': users.page,
                'pages': users.pages,
                'per_page': users.per_page,
                'total': users.total,
                'has_next': users.has_next,
                'has_prev': users.has_prev
            },
            'success': True
        }), 200

    except Exception as e:
        logger.error(f"Error listing users: {str(e)}")
        return jsonify({
            'error': 'Internal server error',
            'success': False
        }), 500


@app.errorhandler(404)
def not_found(error):
    """Handle 404 errors."""
    return jsonify({
        'error': 'Endpoint not found',
        'success': False
    }), 404


@app.errorhandler(405)
def method_not_allowed(error):
    """Handle 405 errors."""
    return jsonify({
        'error': 'Method not allowed',
        'success': False
    }), 405


@app.errorhandler(500)
def internal_error(error):
    """Handle 500 errors."""
    db.session.rollback()
    return jsonify({
        'error': 'Internal server error',
        'success': False
    }), 500


# Initialize database
with app.app_context():
    db.create_all()


if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)
