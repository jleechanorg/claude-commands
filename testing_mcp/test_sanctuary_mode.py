#!/usr/bin/env python3
"""
Generated by /generatetest - Evidence-Based Test
Focus: sanctuary mode validation
Work Name: sanctuary_mode_validation

REAL MODE ONLY - No mocks, no test mode
Evidence standards: .claude/skills/evidence-standards.md
"""
import argparse
import json
import sys
from datetime import datetime, timezone
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent))

# ‚úÖ MANDATORY: Use shared library utilities
from testing_mcp.lib.evidence_utils import (
    capture_provenance,
    create_evidence_bundle,
    get_evidence_dir,
    save_request_responses,
)
from testing_mcp.lib.mcp_client import MCPClient
from testing_mcp.lib.campaign_utils import (
    advance_to_living_world_turn,
    complete_mission_with_sanctuary,
    create_campaign,
    end_combat_if_active,
    ensure_story_mode,
    get_campaign_state,
    process_action,
)
from testing_mcp.lib.model_utils import settings_for_model, update_user_settings
from testing_mcp.lib.server_utils import pick_free_port, start_local_mcp_server

# Test configuration
WORK_NAME = "sanctuary_mode_validation"
DEFAULT_MODEL = "gemini-3-flash-preview"  # Pin model to avoid fallback noise


def run_tests(server_url: str) -> list:
    """Run sanctuary mode validation tests against real server."""
    client = MCPClient(server_url)
    user_id = f"test-{datetime.now(timezone.utc).strftime('%Y%m%d%H%M%S')}"

    # Pin model to avoid fallback noise
    update_user_settings(
        client,
        user_id=user_id,
        settings=settings_for_model(DEFAULT_MODEL),
    )

    results = []
    request_responses = []

    # Scenario 1: Complete a mission to activate sanctuary
    print("üìã Scenario 1: Complete mission to activate sanctuary...")
    campaign_id = create_campaign(
        client,
        user_id=user_id,
        title="Sanctuary Test Campaign",
    )

    # Exit character creation and ensure Story Mode
    print("   Exiting character creation and seeding game state...")
    ensure_story_mode(
        client,
        user_id=user_id,
        campaign_id=campaign_id,
        request_responses=request_responses,
    )

    # Start the quest in Story Mode
    quest_start_response = process_action(
        client,
        user_id=user_id,
        campaign_id=campaign_id,
        user_input="I begin my quest to clear the goblin cave near Phandalin.",
    )
    request_responses.extend(client.get_captures_as_dict())
    client.clear_captures()

    # Advance the quest (may start combat)
    progress_response = process_action(
        client,
        user_id=user_id,
        campaign_id=campaign_id,
        user_input="I enter the goblin cave and fight through the goblins, reaching the chief's chamber.",
    )
    request_responses.extend(client.get_captures_as_dict())
    client.clear_captures()

    # Complete mission and verify sanctuary activation (shared utility handles combat ending)
    completion_result = complete_mission_with_sanctuary(
        client,
        user_id=user_id,
        campaign_id=campaign_id,
        completion_text="The quest is finished. I have successfully completed the Cragmaw Hideout mission. This mission is now complete. I have finished this quest arc.",
        request_responses=request_responses,
        verbose=True,
    )
    
    completion_response = completion_result["completion_response"]
    sanctuary_mode = completion_result["sanctuary_mode"]
    sanctuary_active = completion_result["sanctuary_active"]
    current_turn = completion_result["current_turn"]
    expires_turn = sanctuary_mode.get("expires_turn")
    activated_turn = sanctuary_mode.get("activated_turn")
    
    # Check completion response for sanctuary activation hints
    completion_narrative = completion_response.get("narrative", "").lower()
    has_completion_language = any(
        phrase in completion_narrative
        for phrase in ["complete", "finished", "accomplished", "victory", "success"]
    )

    scenario1_passed = (
        sanctuary_active
        and expires_turn is not None
        and activated_turn is not None
        and expires_turn > current_turn
    )
    
    # Diagnostic info
    diagnostic_info = {
        "completion_narrative_length": len(completion_narrative),
        "has_completion_language": has_completion_language,
        "state_keys": list(state.keys()),
        "custom_campaign_state_keys": list(state.get("custom_campaign_state", {}).keys()),
    }

    results.append(
        {
            "name": "Sanctuary activation after mission completion",
            "campaign_id": campaign_id,
            "passed": scenario1_passed,
            "errors": []
            if scenario1_passed
            else [
                f"Sanctuary not activated: active={sanctuary_active}, "
                f"expires_turn={expires_turn}, activated_turn={activated_turn}, "
                f"current_turn={current_turn}. "
                f"LLM may not have recognized mission completion or written to state_updates."
            ],
            "sanctuary_mode": sanctuary_mode,
            "current_turn": current_turn,
            "diagnostic_info": diagnostic_info,
            "completion_narrative_snippet": completion_narrative[:300] if completion_narrative else "",
        }
    )

    # Scenario 2: Verify sanctuary prevents lethal events
    print("üìã Scenario 2: Verify sanctuary prevents lethal events...")
    if sanctuary_active:
        # ‚úÖ CRITICAL: Ensure this happens on a Living World turn (every 3 turns)
        # Living World turns are when complications can emerge from off-screen events
        # Sanctuary should prevent lethal complications during Living World advancement
        current_turn, was_living_world_turn = advance_to_living_world_turn(
            client,
            user_id=user_id,
            campaign_id=campaign_id,
            request_responses=request_responses,
            verbose=True,
        )
        
        # Try to trigger an event that should be blocked by sanctuary
        # On Living World turns, complications can emerge from off-screen events
        event_response = process_action(
            client,
            user_id=user_id,
            campaign_id=campaign_id,
            user_input="I explore the forest looking for adventure.",
        )
        request_responses.extend(client.get_captures_as_dict())
        client.clear_captures()

        narrative = event_response.get("narrative", "").lower()
        # Check that narrative doesn't contain lethal events
        lethal_keywords = [
            "assassination",
            "ambush",
            "killed",
            "death",
            "dies",
            "slain",
            "murdered",
        ]
        has_lethal_event = any(keyword in narrative for keyword in lethal_keywords)

        # Re-check sanctuary status after action
        state2 = get_campaign_state(client, user_id=user_id, campaign_id=campaign_id)
        request_responses.extend(client.get_captures_as_dict())
        client.clear_captures()

        game_state2 = state2.get("game_state", {})
        sanctuary_still_active = (
            game_state2.get("custom_campaign_state", {})
            .get("sanctuary_mode", {})
            .get("active", False)
        )

        # was_living_world_turn is already set from advance_to_living_world_turn
        final_turn = current_turn
        
        scenario2_passed = (
            not has_lethal_event 
            and sanctuary_still_active 
            and was_living_world_turn  # ‚úÖ Must be a Living World turn
        )

        results.append(
            {
                "name": "Sanctuary prevents lethal events",
                "campaign_id": campaign_id,
                "passed": scenario2_passed,
                "errors": []
                if scenario2_passed
                else [
                    f"Lethal event detected: {has_lethal_event}, "
                    f"sanctuary still active: {sanctuary_still_active}, "
                    f"was Living World turn: {was_living_world_turn} (turn {final_turn})"
                ],
                "narrative_snippet": narrative[:200] if narrative else "",
                "has_lethal_event": has_lethal_event,
                "sanctuary_still_active": sanctuary_still_active,
                "was_living_world_turn": was_living_world_turn,
                "turn_number": final_turn,
            }
        )
    else:
        results.append(
            {
                "name": "Sanctuary prevents lethal events",
                "campaign_id": campaign_id,
                "passed": False,
                "errors": ["Cannot test: sanctuary not active from scenario 1"],
            }
        )

    # Scenario 3: Break sanctuary with major aggression
    print("üìã Scenario 3: Break sanctuary with major aggression...")
    if sanctuary_active:
        # Check if level-up is pending and complete it first
        state_before_break = get_campaign_state(client, user_id=user_id, campaign_id=campaign_id)
        request_responses.extend(client.get_captures_as_dict())
        client.clear_captures()

        game_state_before_break = state_before_break.get("game_state", {})
        level_up_available = (
            game_state_before_break.get("rewards_pending", {}).get("level_up_available", False)
        )
        char_creation_blocking = game_state_before_break.get("custom_campaign_state", {}).get(
            "character_creation_in_progress", False
        )

        if level_up_available or char_creation_blocking:
            # Complete level-up first
            print("   Level-up detected, completing level-up first...")
            level_up_response = process_action(
                client,
                user_id=user_id,
                campaign_id=campaign_id,
                user_input="I accept the level up and continue adventuring.",
            )
            request_responses.extend(client.get_captures_as_dict())
            client.clear_captures()

        # Now break sanctuary with major aggression - be very explicit
        break_response = process_action(
            client,
            user_id=user_id,
            campaign_id=campaign_id,
            user_input="I declare war on the local lord of Phandalin and launch an attack on his stronghold! This is a major act of aggression that should break my sanctuary protection.",
        )
        request_responses.extend(client.get_captures_as_dict())
        client.clear_captures()

        # Check if sanctuary was broken
        state3 = get_campaign_state(client, user_id=user_id, campaign_id=campaign_id)
        request_responses.extend(client.get_captures_as_dict())
        client.clear_captures()

        game_state3 = state3.get("game_state", {})
        sanctuary_mode_after = (
            game_state3.get("custom_campaign_state", {}).get("sanctuary_mode", {})
        )
        # Sanctuary is broken if: active=false AND (broken=true OR reason indicates breaking)
        active_after = sanctuary_mode_after.get("active", True)
        broken_flag = sanctuary_mode_after.get("broken", False)
        broken_reason = sanctuary_mode_after.get("broken_reason", "")
        reason_field = sanctuary_mode_after.get("reason", "")
        
        # Check if reason indicates breaking (even if broken flag not set)
        reason_indicates_break = any(
            keyword in (broken_reason + " " + reason_field).lower()
            for keyword in ["war", "attack", "hostile", "aggression", "broken", "shattered"]
        )
        
        sanctuary_broken = (
            not active_after and (broken_flag or reason_indicates_break)
        )

        results.append(
            {
                "name": "Sanctuary breaks on major aggression",
                "campaign_id": campaign_id,
                "passed": sanctuary_broken,
                "errors": []
                if sanctuary_broken
                else [
                    f"Sanctuary not broken: active={sanctuary_mode_after.get('active')}, "
                    f"broken={sanctuary_mode_after.get('broken')}, "
                    f"reason={sanctuary_mode_after.get('reason', '')}, "
                    f"broken_reason={sanctuary_mode_after.get('broken_reason', '')}"
                ],
                "sanctuary_mode_after": sanctuary_mode_after,
            }
        )
    else:
        results.append(
            {
                "name": "Sanctuary breaks on major aggression",
                "campaign_id": campaign_id,
                "passed": False,
                "errors": ["Cannot test: sanctuary not active from scenario 1"],
            }
        )

    # Scenario 4: Verify sanctuary structure matches schema
    print("üìã Scenario 4: Verify sanctuary structure matches schema...")
    if sanctuary_mode:
        required_fields = ["active", "expires_turn", "activated_turn", "arc", "scale"]
        missing_fields = [
            field for field in required_fields if field not in sanctuary_mode
        ]

        scenario4_passed = len(missing_fields) == 0

        results.append(
            {
                "name": "Sanctuary structure matches schema",
                "campaign_id": campaign_id,
                "passed": scenario4_passed,
                "errors": []
                if scenario4_passed
                else [f"Missing required fields: {missing_fields}"],
                "sanctuary_mode": sanctuary_mode,
                "required_fields": required_fields,
            }
        )
    else:
        results.append(
            {
                "name": "Sanctuary structure matches schema",
                "campaign_id": campaign_id,
                "passed": False,
                "errors": ["Cannot test: sanctuary_mode not present"],
            }
        )

    return results, request_responses


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--work-name", default=WORK_NAME)
    parser.add_argument("--server", help="Optional: use existing server URL (default: start fresh)")
    args = parser.parse_args()

    # ‚úÖ MANDATORY: Always start fresh local server with free port
    local_server = None
    server_url = args.server

    if not server_url:
        # Start fresh server on free port
        port = pick_free_port()
        print(f"üöÄ Starting fresh local MCP server on port {port}...")
        local_server = start_local_mcp_server(port)
        server_url = local_server.base_url

        # Wait for server to be ready
        client = MCPClient(server_url)
        client.wait_healthy(timeout_s=30.0)
        print(f"‚úÖ Server ready at {server_url}")

    try:
        # Run tests against REAL server
        results, request_responses = run_tests(server_url)

        # ‚úÖ MANDATORY: Always save evidence (no optional flag)
        evidence_dir = get_evidence_dir(args.work_name)
        server_pid = local_server.pid if local_server else None
        provenance = capture_provenance(server_url, server_pid=server_pid)

        # Save request/response pairs
        if request_responses:
            save_request_responses(evidence_dir, request_responses)

        # Create evidence bundle using shared lib
        bundle_files = create_evidence_bundle(
            evidence_dir=evidence_dir,
            test_name=args.work_name,
            results={"scenarios": results, "summary": {"total_scenarios": len(results)}},
            provenance=provenance,
            request_responses=request_responses,
            server_log_path=local_server.log_path if local_server else None,
        )

        print(f"üì¶ Evidence bundle created: {evidence_dir}")
        print(f"   Files: {len(bundle_files)} with checksums")

        # Print summary
        passed = sum(1 for r in results if r.get("passed", False))
        total = len(results)
        print(f"\nüìä Test Results: {passed}/{total} passed")
        for result in results:
            status = "‚úÖ" if result.get("passed", False) else "‚ùå"
            print(f"   {status} {result['name']}")

    finally:
        # Clean up local server if we started it
        if local_server:
            print("üõë Stopping local server...")
            local_server.stop()


if __name__ == "__main__":
    main()
